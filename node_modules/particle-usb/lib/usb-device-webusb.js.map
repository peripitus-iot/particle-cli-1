{"version":3,"sources":["../src/usb-device-webusb.js"],"names":["MAX_CONTROL_TRANSFER_DATA_SIZE","bmRequestTypeToString","type","bmRequestTypeToRecipientString","UsbDevice","constructor","dev","_dev","timeout","open","err","UsbError","close","transferIn","setup","res","controlTransferIn","requestType","bmRequestType","recipient","request","bRequest","value","wValue","index","wIndex","wLength","Buffer","from","data","buffer","transferOut","controlTransferOut","claimInterface","intrface","releaseInterface","setAltSetting","setting","selectAlternateInterface","vendorId","productId","serialNumber","isOpen","opened","internalObject","getUsbDevices","filters","forEach","f","RangeError","devs","newDev","navigator","usb","requestDevice","e","name","getDevices","length","filter","some","hasNewDev","push","map"],"mappings":"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","sourcesContent":["import { UsbError } from './error';\n\n// Maximum size of a control transfer's data stage\nexport const MAX_CONTROL_TRANSFER_DATA_SIZE = 4096;\n\nfunction bmRequestTypeToString(type) {\n\ttype = (type >> 5) & 0x03;\n\tswitch (type) {\n\t\tcase 0: {\n\t\t\treturn 'standard';\n\t\t}\n\t\tcase 1: {\n\t\t\treturn 'class';\n\t\t}\n\t\tcase 2: {\n\t\t\treturn 'vendor';\n\t\t}\n\t\tdefault: {\n\t\t\treturn 'unknown';\n\t\t}\n\t}\n}\n\nfunction bmRequestTypeToRecipientString(type) {\n\ttype = type & 0x0f;\n\tswitch (type) {\n\t\tcase 0: {\n\t\t\treturn 'device';\n\t\t}\n\t\tcase 1: {\n\t\t\treturn 'interface';\n\t\t}\n\t\tcase 2: {\n\t\t\treturn 'endpoint';\n\t\t}\n\t\tcase 3:\n\t\tdefault: {\n\t\t\treturn 'other';\n\t\t}\n\t}\n}\n\nexport class UsbDevice {\n\tconstructor(dev) {\n\t\tthis._dev = dev;\n\t\tthis._dev.timeout = 5000; // Use longer timeout for control transfers\n\t}\n\n\tasync open() {\n\t\ttry {\n\t\t\tawait this._dev.open();\n\t\t} catch (err) {\n\t\t\tthrow new UsbError(err, 'Unable to open USB device');\n\t\t}\n\t}\n\n\tasync close() {\n\t\ttry {\n\t\t\tawait this._dev.close();\n\t\t} catch (err) {\n\t\t\tthrow new UsbError(err, 'Unable to close USB device');\n\t\t}\n\t}\n\n\tasync transferIn(setup) {\n\t\ttry {\n\t\t\tconst res = await this._dev.controlTransferIn({\n\t\t\t\trequestType: bmRequestTypeToString(setup.bmRequestType),\n\t\t\t\trecipient: bmRequestTypeToRecipientString(setup.bmRequestType),\n\t\t\t\trequest: setup.bRequest,\n\t\t\t\tvalue: setup.wValue,\n\t\t\t\tindex: setup.wIndex\n\t\t\t}, setup.wLength);\n\t\t\treturn Buffer.from(res.data.buffer);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError(err, 'IN control transfer failed');\n\t\t}\n\t}\n\n\tasync transferOut(setup, data) {\n\t\ttry {\n\t\t\tawait this._dev.controlTransferOut({\n\t\t\t\trequestType: bmRequestTypeToString(setup.bmRequestType),\n\t\t\t\trecipient: bmRequestTypeToRecipientString(setup.bmRequestType),\n\t\t\t\trequest: setup.bRequest,\n\t\t\t\tvalue: setup.wValue,\n\t\t\t\tindex: setup.wIndex\n\t\t\t}, data); // data is optional\n\t\t} catch (err) {\n\t\t\tthrow new UsbError(err, 'OUT control transfer failed');\n\t\t}\n\t}\n\n\tasync claimInterface(intrface) {\n\t\ttry {\n\t\t\tawait this._dev.claimInterface(intrface);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError(err, 'Failed to claim interface');\n\t\t}\n\t}\n\n\tasync releaseInterface(intrface) {\n\t\ttry {\n\t\t\tawait this._dev.releaseInterface(intrface);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError(err, 'Failed to release interface');\n\t\t}\n\t}\n\n\tasync setAltSetting(intrface, setting) {\n\t\ttry {\n\t\t\tawait this._dev.selectAlternateInterface(intrface, setting);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError(err, 'Failed to set alt setting');\n\t\t}\n\t}\n\n\tget vendorId() {\n\t\treturn this._dev.vendorId;\n\t}\n\n\tget productId() {\n\t\treturn this._dev.productId;\n\t}\n\n\tget serialNumber() {\n\t\treturn this._dev.serialNumber;\n\t}\n\n\tget isOpen() {\n\t\treturn this._dev.opened;\n\t}\n\n\tget internalObject() {\n\t\treturn this._dev;\n\t}\n}\n\nexport async function getUsbDevices(filters) {\n\tif (filters) {\n\t\t// Validate filtering options\n\t\tfilters.forEach(f => {\n\t\t\tif (f.productId && !f.vendorId) {\n\t\t\t\tthrow new RangeError('Vendor ID is missing');\n\t\t\t}\n\t\t});\n\t} else {\n\t\tfilters = [];\n\t}\n\tlet devs = [];\n\ttry {\n\t\t// Fow now, always ask the user to grant access to the device, even if we already have a\n\t\t// permission to access it. The permissions API for USB is not yet implemented in Chrome,\n\t\t// and calling requestDevice() after getDevices() causes a SecurityError.\n\t\t// TODO: Implement a separate API to request a permission from the user\n\t\tlet newDev = null;\n\t\ttry {\n\t\t\tnewDev = await navigator.usb.requestDevice({ filters });\n\t\t} catch (e) {\n\t\t\t// Ignore NotFoundError which means that the user has cancelled the request\n\t\t\tif (e.name !== 'NotFoundError') {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t// Get the list of known devices and filter them according to the provided options\n\t\tdevs = await navigator.usb.getDevices();\n\t\tif (filters.length > 0) {\n\t\t\tdevs = devs.filter(dev => filters.some(f => ((!f.vendorId || dev.vendorId === f.vendorId) &&\n\t\t\t\t\t(!f.productId || dev.productId === f.productId) &&\n\t\t\t\t\t(!f.serialNumber || dev.serialNumber === f.serialNumber))));\n\t\t}\n\t\tif (newDev) {\n\t\t\t// Avoid listing the same device twice\n\t\t\tconst hasNewDev = devs.some(dev => dev.vendorId === newDev.vendorId && dev.productId === newDev.productId &&\n\t\t\t\t\tdev.serialNumber === newDev.serialNumber);\n\t\t\tif (!hasNewDev) {\n\t\t\t\tdevs.push(newDev);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\tthrow new UsbError(err, 'Unable to enumerate USB devices');\n\t}\n\tdevs = devs.map(dev => new UsbDevice(dev));\n\treturn devs;\n}\n"],"file":"usb-device-webusb.js"}