"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.getDevices = getDevices;
exports.openDeviceById = openDeviceById;
exports.DeviceBase = exports.PollingPolicy = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/map"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _usbDeviceNode = require("./usb-device-node");

var proto = _interopRequireWildcard(require("./usb-protocol"));

var _deviceType = require("./device-type");

var _error = require("./error");

var _config = require("./config");

var _dfu = require("./dfu");

var _events = _interopRequireDefault(require("events"));

// Device descriptions arranged by vendor/product IDs
const DEVICE_INFO = _deviceType.DEVICES.reduce((obj, dev) => {
  dev = (0, _assign.default)({}, dev);
  const ids = dev.usbIds;
  delete dev.usbIds;
  const dfuIds = dev.dfuUsbIds;
  delete dev.dfuUsbIds;

  if (!(ids.vendorId in obj)) {
    obj[ids.vendorId] = {};
  }

  obj[ids.vendorId][ids.productId] = (0, _assign.default)({
    dfu: false
  }, dev);

  if (!(dfuIds.vendorId in obj)) {
    obj[dfuIds.vendorId] = {};
  }

  obj[dfuIds.vendorId][dfuIds.productId] = (0, _assign.default)({
    dfu: true
  }, dev);
  return obj;
}, {});

function deviceInfoForUsbIds(vendorId, productId) {
  let info = DEVICE_INFO[vendorId];

  if (info) {
    info = info[productId];
  }

  return info;
} // Default backoff intervals for the CHECK service request


const DEFAULT_CHECK_INTERVALS = [50, 50, 100, 100, 250, 250, 500, 500, 1000];

function checkInterval(attempts, intervals) {
  if (attempts < intervals.length) {
    return intervals[attempts];
  }

  return intervals[intervals.length - 1];
}
/**
 * Predefined polling policies.
 */


const PollingPolicy = {
  DEFAULT: n => checkInterval(n, DEFAULT_CHECK_INTERVALS)
}; // Device state

exports.PollingPolicy = PollingPolicy;
const DeviceState = {
  CLOSED: 0,
  OPENING: 1,
  OPEN: 2,
  CLOSING: 3
}; // Low-level vendor requests as defined by the firmware's ctrl_request_type enum

const VendorRequest = {
  SYSTEM_VERSION: 30 // Get system version

}; // Dummy callback function

function ignore() {}
/**
 * Base class for a Particle USB device.
 */


class DeviceBase extends _events.default {
  constructor(dev, info) {
    super();
    this._dev = dev; // USB device handle

    this._info = info; // Device info

    this._log = _config.globalOptions.log; // Logger instance

    this._state = DeviceState.CLOSED; // Device state

    this._reqs = new _map.default(); // All known requests

    this._reqQueue = []; // Unprocessed requests

    this._checkQueue = []; // Active requests that need to be checked

    this._resetQueue = []; // Active requests that need to be reset

    this._activeReqs = 0; // Number of active requests

    this._maxActiveReqs = null; // Maximum number of active requests

    this._lastReqId = 0; // Last used request ID

    this._closeTimer = null; // Timer for the closing operation

    this._wantClose = false; // Set to true if the device needs to be closed

    this._resetAllReqs = false; // Set to true if all requests need to be reset

    this._busy = false; // Set to true if there's an activity on the USB connection

    this._fwVer = null; // Firmware version

    this._id = null; // Device ID

    this._dfu = null; // DFU class implementation
  }
  /**
   * Open the device.
   *
   * @param {Object} options Options.
   * @return {Promise}
   */


  open(options) {
    options = (0, _assign.default)({
      concurrentRequests: null // The maximum number of concurrent requests is limited by the device

    }, options);

    if (this._state !== DeviceState.CLOSED) {
      return _promise.default.reject(new _error.StateError('Device is already open'));
    } // Open USB device


    this._log.trace('Opening device');

    this._state = DeviceState.OPENING;
    return this._dev.open().then(() => {
      // Normalize the device ID string
      this._id = this._dev.serialNumber.replace(/[^\x20-\x7e]/g, '').toLowerCase();

      this._log.trace(`Device ID: ${this._id}`); // Get firmware version


      return this._getFirmwareVersion().then(ver => {
        this._fwVer = ver;

        this._log.trace(`Firmware version: ${this._fwVer}`);
      }).catch(err => {
        // Pre-0.6.0 firmwares and devices in DFU mode don't support the firmware version request
        if (!this._info.dfu) {
          this._log.trace(`Unable to get firmware version: ${err.message}`);
        }
      });
    }).then(() => {
      if (this._info.dfu) {
        this._dfu = new _dfu.Dfu(this._dev, this._log);
        return this._dfu.open(options);
      }
    }).then(() => {
      this._log.trace('Device is open');

      this._maxActiveReqs = options.concurrentRequests;
      this._resetAllReqs = true; // Reset all requests remaining from a previous session

      this._state = DeviceState.OPEN;
      this.emit('open');

      this._process();
    }).catch(err => {
      return this._close(err).catch(ignore).then(() => {
        throw err;
      });
    });
  }
  /**
   * Close the device.
   *
   * @param {Object} options Options.
   * @return {Promise}
   */


  close(options) {
    options = (0, _assign.default)({
      processPendingRequests: true,
      // Process pending requests before closing the device
      timeout: null // Wait until all requests are processed

    }, options);

    if (this._state === DeviceState.CLOSED) {
      return _promise.default.resolve();
    } // Check if pending requests need to be processed before closing the device


    if (!options.processPendingRequests) {
      this._rejectAllRequests(new _error.StateError('Device is being closed'));

      if (this._closeTimer) {
        clearTimeout(this._closeTimer);
        this._closeTimer = null;
      }
    } else if (options.timeout && !this._wantClose) {
      // Timeout cannot be overriden
      this._closeTimer = setTimeout(() => {
        this._rejectAllRequests(new _error.StateError('Device is being closed'));

        this._process();
      }, options.timeout);
    }

    return new _promise.default(resolve => {
      // Use EventEmitter's queue to resolve the promise
      this.once('closed', () => {
        resolve();
      });
      this._wantClose = true;

      this._process();
    });
  }
  /**
   * Send a USB control request.
   *
   * @param {Number} type Request type.
   * @param {Buffer|String} data Request data.
   * @param {Object} options Request options.
   * @return {Promise}
   */


  sendControlRequest(type, data, options) {
    options = (0, _assign.default)({
      pollingPolicy: PollingPolicy.DEFAULT,
      // Polling policy
      timeout: _config.globalOptions.requestTimeout // Request timeout

    }, options);
    return new _promise.default((resolve, reject) => {
      if (this._state === DeviceState.CLOSED) {
        throw new _error.StateError('Device is not open');
      }

      if (this._state === DeviceState.CLOSING || this._wantClose) {
        throw new _error.StateError('Device is being closed');
      }

      if (type < 0 || type > proto.MAX_REQUEST_TYPE) {
        throw new RangeError('Invalid request type');
      }

      const dataIsStr = typeof data === 'string';

      if (dataIsStr) {
        data = Buffer.from(data);
      }

      if (data && data.length > proto.MAX_PAYLOAD_SIZE) {
        throw new RangeError('Request data is too large');
      }

      const req = {
        id: ++this._lastReqId,
        // Internal request ID
        type: type,
        data: data,
        dataIsStr: dataIsStr,
        dataSent: false,
        protoId: null,
        // Protocol request ID
        checkInterval: options.pollingPolicy,
        checkIntervalIsFunc: typeof options.pollingPolicy === 'function',
        checkTimer: null,
        checkCount: 0,
        reqTimer: null,
        resolve: resolve,
        reject: reject,
        done: false
      };

      if (options.timeout) {
        // Start request timer
        req.reqTimer = setTimeout(() => {
          this._rejectRequest(req, new _error.TimeoutError('Request timeout'));

          this._process();
        }, options.timeout);
      }

      this._reqs.set(req.id, req);

      this._reqQueue.push(req);

      this._log.trace(`Request ${req.id}: Enqueued`);

      this._process();
    });
  }
  /**
   * Perform the system reset.
   * This function only works in DFU mode.
   *
   * @return {Promise}
   */


  async reset() {
    if (this._dfu) {
      return this._dfu.leave();
    }

    throw new _error.StateError();
  }
  /**
   * Set to `true` if the device is open.
   */


  get isOpen() {
    return this._state !== DeviceState.CLOSED;
  }
  /**
   * Device ID. Set to `null` if the device is not open.
   */


  get id() {
    return this._id;
  }
  /**
   * Firmware version. Set to `null` if the device is not open, or the version could not be determined.
   */


  get firmwareVersion() {
    return this._fwVer;
  }
  /**
   * Device type.
   */


  get type() {
    return this._info.type;
  }
  /**
   * Platform ID.
   */


  get platformId() {
    return this._info.platformId;
  }
  /**
   * Set to `true` if this is a Core device.
   */


  get isCore() {
    return this.type === _deviceType.DeviceType.CORE;
  }
  /**
   * Set to `true` if this is a Photon device.
   */


  get isPhoton() {
    return this.type === _deviceType.DeviceType.PHOTON;
  }
  /**
   * Set to `true` if this is a P1 device.
   */


  get isP1() {
    return this.type === _deviceType.DeviceType.P1;
  }
  /**
   * Set to `true` if this is an Electron device.
   */


  get isElectron() {
    return this.type === _deviceType.DeviceType.ELECTRON;
  }
  /**
   * Set to `true` if this is a Duo device.
   */


  get isDuo() {
    return this.type === _deviceType.DeviceType.DUO;
  }
  /**
   * Set to `true` if this is a Xenon device.
   */


  get isXenon() {
    return this.type === _deviceType.DeviceType.XENON;
  }
  /**
   * Set to `true` if this is a Xenon device.
   */


  get isArgon() {
    return this.type === _deviceType.DeviceType.ARGON;
  }
  /**
   * Set to `true` if this is a Xenon device.
   */


  get isBoron() {
    return this.type === _deviceType.DeviceType.BORON;
  }
  /**
   * USB vendor ID.
   */


  get vendorId() {
    return this._dev.vendorId;
  }
  /**
   * USB product ID.
   */


  get productId() {
    return this._dev.productId;
  }
  /**
   * Set to `true` if this device is in the DFU mode.
   */


  get isInDfuMode() {
    return this._info.dfu;
  }
  /**
   * Returns an internal USB device handle.
   */


  get usbDevice() {
    return this._dev;
  }

  _process() {
    if (this._state === DeviceState.CLOSED || this._state === DeviceState.OPENING || this._busy) {
      return;
    }

    if (this._wantClose && this._state !== DeviceState.CLOSING) {
      this._log.trace('Closing device');

      this._state = DeviceState.CLOSING;
    }

    if (this._resetAllRequests()) {
      return;
    }

    if (this._resetNextRequest()) {
      return;
    }

    if (this._checkNextRequest()) {
      return;
    }

    if (this._sendNextRequest()) {
      return;
    }

    if (this._state === DeviceState.CLOSING && this._activeReqs === 0) {
      this._close();
    }
  }

  _resetAllRequests() {
    if (!this._resetAllReqs) {
      return false;
    }

    this._log.trace('Sending RESET');

    (0, _error.assert)(!this._busy);
    this._busy = true;
    const setup = proto.resetRequest();

    this._sendServiceRequest(setup).catch(ignore).then(() => {
      // Ignore result
      this._resetAllReqs = false;
      this._activeReqs = 0;
    }).finally(() => {
      this._busy = false;

      this._process();
    });

    return true;
  }

  _resetNextRequest() {
    if (this._resetQueue.length === 0) {
      return false;
    }

    const req = this._resetQueue.shift();

    this._log.trace(`Request ${req.id}: Sending RESET`);

    (0, _error.assert)(!this._busy && req.protoId);
    this._busy = true;
    const setup = proto.resetRequest(req.protoId);

    this._sendServiceRequest(setup).catch(ignore).then(() => {
      // Ignore result
      (0, _error.assert)(--this._activeReqs >= 0);
    }).finally(() => {
      this._busy = false;

      this._process();
    });

    return true;
  }

  _checkNextRequest() {
    let req = null;

    while (this._checkQueue.length !== 0) {
      const r = this._checkQueue.shift();

      if (!r.done) {
        // Skip cancelled requests
        req = r;
        break;
      }
    }

    if (!req) {
      return false;
    }

    this._log.trace(`Request ${req.id}: Sending CHECK (${req.checkCount})`);

    (0, _error.assert)(!this._busy && req.protoId);
    this._busy = true;
    const setup = proto.checkRequest(req.protoId);

    this._sendServiceRequest(setup).then(srep => {
      this._log.trace(`Request ${req.id}: Status: ${srep.status}`);

      switch (srep.status) {
        case proto.Status.OK:
          {
            if (req.dataSent) {
              // Request processing is completed
              const rep = {
                result: srep.result
              };

              if (srep.size) {
                // Receive payload data
                return this._recvReplyData(req, srep.size).then(data => {
                  rep.data = req.dataIsStr ? data.toString() : data;

                  this._resolveRequest(req, rep);
                });
              } else {
                this._resolveRequest(req, rep); // No reply data

              }
            } else {
              // Buffer allocation is completed, send payload data
              return this._sendRequestData(req).then(() => {
                req.dataSent = true;
                req.checkCount = 0; // Reset check counter

                this._startCheckTimer(req);
              });
            }

            break;
          }

        case proto.Status.PENDING:
          {
            this._startCheckTimer(req);

            break;
          }

        case proto.Status.NO_MEMORY:
          {
            throw new _error.MemoryError('Memory allocation error');
          }

        case proto.Status.NOT_FOUND:
          {
            throw new _error.DeviceError('Request was cancelled');
          }

        default:
          {
            throw new _error.ProtocolError(`Unknown status code: ${srep.status}`);
          }
      }
    }).catch(err => {
      this._rejectRequest(req, err);
    }).finally(() => {
      this._busy = false;

      this._process();
    });

    return true;
  }

  _sendNextRequest() {
    if (this._maxActiveReqs && this._activeReqs >= this._maxActiveReqs) {
      return false;
    }

    let req = null;

    while (this._reqQueue.length !== 0) {
      const r = this._reqQueue.shift();

      if (!r.done) {
        // Skip cancelled requests
        req = r;
        break;
      }
    }

    if (!req) {
      return false;
    }

    this._log.trace(`Request ${req.id}: Sending INIT`);

    (0, _error.assert)(!this._busy);
    this._busy = true;
    const setup = proto.initRequest(req.type, req.data ? req.data.length : 0);

    this._sendServiceRequest(setup).then(srep => {
      this._log.trace(`Request ${req.id}: Status: ${srep.status}`);

      if (srep.status === proto.Status.OK || srep.status === proto.Status.PENDING) {
        req.protoId = srep.id;
        ++this._activeReqs;

        this._log.trace(`Request ${req.id}: Protocol ID: ${req.protoId}`);
      }

      switch (srep.status) {
        case proto.Status.OK:
          {
            if (req.data && req.data.length > 0) {
              // Send payload data
              return this._sendRequestData(req).then(() => {
                req.dataSent = true;

                this._startCheckTimer(req);
              });
            } else {
              req.dataSent = true; // No payload data

              this._startCheckTimer(req);
            }

            break;
          }

        case proto.Status.PENDING:
          {
            if (!req.data || req.data.length === 0) {
              throw new _error.ProtocolError(`Unexpected status code: ${srep.status}`);
            } // Buffer allocation is pending


            this._startCheckTimer(req);

            break;
          }

        case proto.Status.BUSY:
          {
            // Update maximum number of active requests
            this._maxActiveReqs = this._activeReqs; // Return the request back to queue

            this._reqQueue.unshift(req);

            break;
          }

        case proto.Status.NO_MEMORY:
          {
            throw new _error.MemoryError('Memory allocation error');
          }

        default:
          {
            throw new _error.ProtocolError(`Unknown status code: ${srep.status}`);
          }
      }
    }).catch(err => {
      this._rejectRequest(req, err);
    }).finally(() => {
      this._busy = false;

      this._process();
    });

    return true;
  }

  _sendRequestData(req) {
    (0, _error.assert)(req.data && req.data.length > 0);
    let offs = 0;

    const sendNextChunk = () => {
      const chunkSize = Math.min(_usbDeviceNode.MAX_CONTROL_TRANSFER_DATA_SIZE, req.data.length - offs);
      const chunk = req.data.slice(offs, offs + chunkSize);

      this._log.trace(`Request ${req.id}: Sending SEND`);

      const setup = proto.sendRequest(req.protoId, chunkSize);
      return this._dev.transferOut(setup, chunk).then(() => {
        this._log.trace(`Request ${req.id}: Sent ${chunkSize} bytes`);

        offs += chunkSize;

        if (offs < req.data.length) {
          if (req.done) {
            throw new Error('Control transfer cancelled');
          }

          return sendNextChunk();
        }
      });
    };

    return sendNextChunk();
  }

  _recvReplyData(req, size) {
    (0, _error.assert)(size > 0);
    const buf = Buffer.alloc(size);
    let offs = 0;

    const recvNextChunk = () => {
      const chunkSize = Math.min(_usbDeviceNode.MAX_CONTROL_TRANSFER_DATA_SIZE, size - offs);

      this._log.trace(`Request ${req.id}: Sending RECV`);

      const setup = proto.recvRequest(req.protoId, chunkSize);
      return this._dev.transferIn(setup).then(data => {
        this._log.trace(`Request ${req.id}: Received ${data.length} bytes`);

        if (data.length !== chunkSize) {
          throw new Error('Unexpected size of the control transfer');
        }

        data.copy(buf, offs);
        offs += chunkSize;

        if (offs < size) {
          if (req.done) {
            throw new Error('Control transfer cancelled');
          }

          return recvNextChunk();
        }

        return buf;
      });
    };

    return recvNextChunk();
  }

  _close(err = null) {
    (0, _error.assert)(!this._busy); // Cancel all requests

    if (this._reqs.size !== 0) {
      if (!err) {
        err = new _error.StateError('Device has been closed');
      }

      this._rejectAllRequests(err);
    }

    this._activeReqs = 0;
    this._resetAllReqs = false; // Cancel timers

    if (this._closeTimer) {
      clearTimeout(this._closeTimer);
      this._closeTimer = null;
    }

    let p = _promise.default.resolve();

    if (this._dfu) {
      p = p.then(() => this._dfu.close()).catch(err => {
        this._log.warn(`Unable to close DFU interface: ${err.message}`);
      });
    } // Close USB device


    return p.then(() => this._dev.close()).catch(err => {
      this._log.warn(`Unable to close USB device: ${err.message}`);
    }).then(() => {
      // Reset device state
      const emitEvent = this._state === DeviceState.CLOSING;
      this._state = DeviceState.CLOSED;
      this._wantClose = false;
      this._maxActiveReqs = null;
      this._fwVer = null;
      this._id = null;

      if (emitEvent) {
        this.emit('closed');
      }
    });
  }

  _rejectAllRequests(err) {
    this._reqs.forEach(req => {
      this._rejectRequest(req, err);
    });

    this._reqQueue = [];
    this._checkQueue = [];
    this._resetQueue = [];

    if (this._activeReqs > 0) {
      this._resetAllReqs = true;
    }
  }

  _rejectRequest(req, err) {
    if (req.done) {
      return;
    }

    this._log.trace(`Request ${req.id}: Failed: ${err.message}`);

    this._clearRequest(req);

    if (req.protoId) {
      this._resetQueue.push(req);
    }

    req.reject(err);
  }

  _resolveRequest(req, rep) {
    if (req.done) {
      return;
    }

    this._log.trace(`Request ${req.id}: Completed`);

    this._clearRequest(req);

    (0, _error.assert)(--this._activeReqs >= 0);
    req.resolve(rep);
  }

  _clearRequest(req) {
    if (req.checkTimer) {
      clearTimeout(req.checkTimer);
      req.checkTimer = null;
    }

    if (req.reqTimer) {
      clearTimeout(req.reqTimer);
      req.reqTimer = null;
    }

    this._reqs.delete(req.id);

    req.done = true;
  }

  _startCheckTimer(req) {
    let timeout = req.checkInterval;

    if (req.checkIntervalIsFunc) {
      timeout = timeout(req.checkCount);
    }

    ++req.checkCount;
    setTimeout(() => {
      this._checkQueue.push(req);

      this._process();
    }, timeout);
  }

  _getFirmwareVersion() {
    const setup = {
      bmRequestType: proto.BmRequestType.DEVICE_TO_HOST,
      bRequest: proto.PARTICLE_BREQUEST,
      wIndex: VendorRequest.SYSTEM_VERSION,
      wValue: 0,
      wLength: proto.MIN_WLENGTH
    };
    return this._dev.transferIn(setup).then(data => {
      return data.toString();
    });
  } // Sends a service request and parses the reply data


  _sendServiceRequest(setup) {
    return this._dev.transferIn(setup).then(data => {
      return proto.parseReply(data);
    });
  }

}
/**
 * Enumerate Particle devices attached to the host.
 *
 * @param {Object} options Options.
 * @param {Array<String>} [options.types] Device types.
 * @param {Boolean} [options.includeDfu] `true` to include devices in DFU mode.
 * @return {Promise}
 */


exports.DeviceBase = DeviceBase;

async function getDevices({
  types = [],
  includeDfu = true
} = {}) {
  types = types.map(type => type.toLowerCase());
  const filters = [];

  _deviceType.DEVICES.forEach(dev => {
    if (types.length === 0 || types.includes(dev.type.toLowerCase())) {
      filters.push(dev.usbIds);

      if (includeDfu) {
        filters.push(dev.dfuUsbIds);
      }
    }
  });

  if (filters.length === 0) {
    return [];
  }

  const devs = await (0, _usbDeviceNode.getUsbDevices)(filters);
  return devs.map(dev => {
    const info = deviceInfoForUsbIds(dev.vendorId, dev.productId);
    (0, _error.assert)(info);
    return new DeviceBase(dev, info);
  });
}
/**
 * Open a device with the specified ID.
 *
 * @param {String} id Device ID.
 * @param {Object} [options] Options.
 * @return {Promise}
 */


async function openDeviceById(id, options = null) {
  const log = _config.globalOptions.log;
  const filters = [];

  _deviceType.DEVICES.forEach(dev => {
    filters.push((0, _assign.default)({
      serialNumber: id
    }, dev.usbIds));
    filters.push((0, _assign.default)({
      serialNumber: id
    }, dev.dfuUsbIds));
  });

  const devs = await (0, _usbDeviceNode.getUsbDevices)(filters);

  if (devs.length === 0) {
    throw new _error.NotFoundError('Device is not found');
  }

  if (devs.length !== 1) {
    log.warn(`Found multiple devices with the same ID: ${id}`); // lol
  }

  let dev = devs[0];
  const info = deviceInfoForUsbIds(dev.vendorId, dev.productId);
  (0, _error.assert)(info);
  dev = new DeviceBase(dev, info);
  await dev.open(options);
  return dev;
}
//# sourceMappingURL=device-base.js.map