"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.Device = exports.LogLevel = exports.DeviceMode = exports.FirmwareModule = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

var _deviceBase = require("./device-base");

var _request = require("./request");

var _result = require("./result");

var _protobufUtil = require("./protobuf-util");

var usbProto = _interopRequireWildcard(require("./usb-protocol"));

var _error = require("./error");

var _config = require("./config");

var _protocol = _interopRequireDefault(require("./protocol"));

/**
 * Firmware module types.
 */
const FirmwareModule = (0, _protobufUtil.fromProtobufEnum)(_protocol.default.FirmwareModuleType, {
  BOOTLOADER: 'BOOTLOADER',
  SYSTEM_PART: 'SYSTEM_PART',
  USER_PART: 'USER_PART',
  MONO_FIRMWARE: 'MONO_FIRMWARE'
});
/**
 * Device modes.
 */

exports.FirmwareModule = FirmwareModule;
const DeviceMode = (0, _protobufUtil.fromProtobufEnum)(_protocol.default.DeviceMode, {
  NORMAL: 'NORMAL_MODE',
  LISTENING: 'LISTENING_MODE'
});
/**
 * Logging levels.
 */

exports.DeviceMode = DeviceMode;
const LogLevel = (0, _protobufUtil.fromProtobufEnum)(_protocol.default.logging.LogLevel, {
  ALL: 'ALL',
  TRACE: 'TRACE',
  INFO: 'INFO',
  WARN: 'WARN',
  ERROR: 'ERROR',
  NONE: 'NONE'
});
exports.LogLevel = LogLevel;
const DEFAULT_FIRMWARE_UPDATE_TIMEOUT = 120000; // Helper class used by Device.timeout()

class RequestSender {
  constructor(device, timeout) {
    this.id = device.id;
    this.device = device;
    this._timeoutTime = (0, _now.default)() + timeout;
  }

  async open(options) {
    this.device = await (0, _deviceBase.openDeviceById)(this.id, options);
  }

  async close() {
    await this.device.close();
  }

  async sendRequest(req, msg, opts) {
    if (!opts || !opts.timeout) {
      const t = this._timeoutTime - (0, _now.default)();

      if (t <= 0) {
        throw new _error.TimeoutError();
      }

      opts = (0, _assign.default)({}, opts, {
        timeout: t
      });
    } else if ((0, _now.default)() + opts.timeout >= this._timeoutTime) {
      throw new _error.TimeoutError();
    }

    return this.device.sendRequest(req, msg, opts);
  }

  async delay(ms) {
    if ((0, _now.default)() + ms >= this._timeoutTime) {
      throw new _error.TimeoutError();
    }

    return new _promise.default(resolve => {
      setTimeout(() => resolve(), ms);
    });
  }

}
/**
 * Basic functionality supported by all Particle devices.
 */


class Device extends _deviceBase.DeviceBase {
  /**
   * Get device serial number
   *
   * @return {Promise}
   */
  async getSerialNumber({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    const r = await this.sendRequest(_request.Request.GET_SERIAL_NUMBER, null
    /* msg */
    , {
      timeout
    });
    return r.serial;
  }
  /**
   * Perform the system reset.
   *
   * @return {Promise}
   */


  async reset({
    force = false,
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    if (this.isInDfuMode) {
      return super.reset();
    }

    if (!force) {
      return this.sendRequest(_request.Request.RESET, null
      /* msg */
      , {
        timeout
      });
    }

    const setup = {
      bmRequestType: usbProto.BmRequestType.HOST_TO_DEVICE,
      bRequest: usbProto.PARTICLE_BREQUEST,
      wIndex: _request.Request.RESET.id,
      wValue: 0
    };
    return this.usbDevice.transferOut(setup);
  }
  /**
   * Perform the factory reset.
   *
   * @return {Promise}
   */


  factoryReset({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    return this.sendRequest(_request.Request.FACTORY_RESET, null
    /* msg */
    , {
      timeout
    });
  }
  /**
   * Reset and enter the DFU mode.
   *
   * @return {Promise}
   */


  enterDfuMode({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    if (this.isInDfuMode) {
      return;
    }

    return this.timeout(timeout, async s => {
      await s.sendRequest(_request.Request.DFU_MODE);
      await s.close();
      let isInDfuMode;

      while (!isInDfuMode) {
        try {
          await s.open({
            includeDfu: true
          });
          isInDfuMode = s.device.isInDfuMode;
        } catch (error) {// device is reconnecting, ignore
        }

        await s.close();
        await s.delay(500);
      }
    });
  }
  /**
   * Reset and enter the safe mode.
   *
   * @return {Promise}
   */


  enterSafeMode({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    return this.sendRequest(_request.Request.SAFE_MODE, null
    /* msg */
    , {
      timeout
    });
  }
  /**
   * Enter the listening mode.
   *
   * @return {Promise}
   */


  async enterListeningMode({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    return this.timeout(timeout, async s => {
      await s.sendRequest(_request.Request.START_LISTENING); // Wait until the device enters the listening mode

      while (true) {
        // eslint-disable-line no-constant-condition
        const r = await s.sendRequest(_request.Request.GET_DEVICE_MODE, null, {
          dontThrow: true // This request may not be supported by the device

        });

        if (r.result !== _result.Result.OK || r.mode === _protocol.default.DeviceMode.LISTENING_MODE) {
          break;
        }

        await s.delay(500);
      }
    });
  }
  /**
   * Leave the listening mode.
   *
   * @return {Promise}
   */


  leaveListeningMode({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    return this.sendRequest(_request.Request.STOP_LISTENING, null
    /* msg */
    , {
      timeout
    });
  }
  /**
   * Get device mode.
   */


  async getDeviceMode({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    const r = await this.sendRequest(_request.Request.GET_DEVICE_MODE, null
    /* msg */
    , {
      timeout
    });
    return DeviceMode.fromProtobuf(r.mode);
  }
  /**
   * Start the Nyan LED indication.
   *
   * @return {Promise}
   */


  startNyanSignal({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    return this.sendRequest(_request.Request.START_NYAN_SIGNAL, null
    /* msg */
    , {
      timeout
    });
  }
  /**
   * Stop the Nyan LED indication.
   *
   * @return {Promise}
   */


  stopNyanSignal({
    timeout = _config.globalOptions.requestTimeout
  } = {}) {
    return this.sendRequest(_request.Request.STOP_NYAN_SIGNAL, null
    /* msg */
    , {
      timeout
    });
  }
  /**
   * Perform the firmware update.
   *
   * @param {Buffer} data Firmware data.
   * @param {Object} [options] Options.
   * @param {Number} [options.timeout] Timeout in milliseconds.
   * @return {Promise}
   */


  async updateFirmware(data, {
    timeout = DEFAULT_FIRMWARE_UPDATE_TIMEOUT
  } = {}) {
    if (!data.length) {
      throw new RangeError('Invalid firmware size');
    }

    return this.timeout(timeout, async s => {
      const {
        chunkSize
      } = await s.sendRequest(_request.Request.START_FIRMWARE_UPDATE, {
        size: data.length
      });
      let offs = 0;

      while (offs < data.length) {
        const n = Math.min(chunkSize, data.length - offs);
        await s.sendRequest(_request.Request.FIRMWARE_UPDATE_DATA, {
          data: data.slice(offs, offs + n)
        });
        offs += n;
      }

      await s.sendRequest(_request.Request.FINISH_FIRMWARE_UPDATE, {
        validateOnly: false
      });
    });
  } // TODO: The methods below are not supported in recent versions of Device OS. Remove them in particle-usb@2.0.0

  /**
   * Get firmware module data.
   *
   * @param {String} module Module type.
   * @param {Number} [index] Module index.
   * @return {Promise<Buffer>}
   */


  getFirmwareModule(module, index) {
    return this._getStorageInfo().then(storage => {
      const section = storage.modules.find(section => {
        return section.moduleType === module && section.moduleIndex === index;
      });

      if (!section) {
        throw new _error.NotFoundError();
      } // Get size of the firmware module


      return this._getSectionDataSize(section).then(size => {
        // Read firmware data
        return this._readSectionData(section, 0, size);
      });
    });
  }
  /**
   * Check if the device runs a modular firmware.
   *
   * @return {Promise<Boolean>}
   */


  hasModularFirmware() {
    return this._getStorageInfo().then(storage => storage.hasModularFirmware);
  }
  /**
   * Set factory firmware.
   *
   * @param {Buffer} data Firmware data.
   * @return {Promise}
   */


  setFactoryFirmware(data) {
    return this._getStorageInfo().then(storage => {
      if (!storage.factory) {
        throw new _error.NotFoundError();
      }

      return this._writeSectionData(storage.factory, 0, data);
    });
  }
  /**
   * Get factory firmware.
   *
   * @return {Promise<Buffer>}
   */


  getFactoryFirmware() {
    return this._getStorageInfo().then(storage => {
      if (!storage.factory) {
        throw new _error.NotFoundError();
      } // Get size of the firmware module


      return this._getSectionDataSize(storage.factory).then(size => {
        // Read firmware data
        return this._readSectionData(storage.factory, 0, size);
      });
    });
  }
  /**
   * Read configuration data.
   *
   * @param {Number} address Address.
   * @param {Number} size Data size.
   * @return {Promise<Buffer>}
   */


  readConfigData(address, size) {
    return this._getStorageInfo().then(storage => {
      if (!storage.config) {
        throw new _error.NotFoundError();
      }

      return this._readSectionData(storage.config, address, size);
    });
  }
  /**
   * Write configuration data.
   *
   * @param {Number} address Address.
   * @param {Buffer} data Data.
   * @return {Promise}
   */


  writeConfigData(address, data) {
    return this._getStorageInfo().then(storage => {
      if (!storage.config) {
        throw new _error.NotFoundError();
      }

      return this._writeSectionData(storage.config, address, data);
    });
  }
  /**
   * Get size of the configuration data.
   *
   * @return {Promise<Number>}
   */


  getConfigDataSize() {
    return this._getStorageInfo().then(storage => {
      if (!storage.config) {
        throw new _error.NotFoundError();
      }

      return storage.config.size;
    });
  }
  /**
   * Read from EEPROM.
   *
   * @param {Number} address Address.
   * @param {Number} size Data size.
   * @return {Promise<Buffer>}
   */


  readEeprom(address, size) {
    return this._getStorageInfo().then(storage => {
      if (!storage.eeprom) {
        throw new _error.NotFoundError();
      }

      return this._readSectionData(storage.eeprom, address, size);
    });
  }
  /**
   * Write to EEPROM.
   *
   * @param {Number} address Address.
   * @param {Buffer} data Data.
   * @return {Promise}
   */


  writeEeprom(address, data) {
    return this._getStorageInfo().then(storage => {
      if (!storage.eeprom) {
        throw new _error.NotFoundError();
      }

      return this._writeSectionData(storage.eeprom, address, data);
    });
  }
  /**
   * Clear EEPROM.
   *
   * @return {Promise}
   */


  clearEeprom() {
    return this._getStorageInfo().then(storage => {
      if (!storage.eeprom) {
        throw new _error.NotFoundError();
      }

      return this._clearSectionData(storage.eeprom);
    });
  }
  /**
   * Get size of the EEPROM.
   *
   * @return {Promise<Number>}
   */


  getEepromSize() {
    return this._getStorageInfo().then(storage => {
      if (!storage.eeprom) {
        throw new _error.NotFoundError();
      }

      return storage.eeprom.size;
    });
  }
  /**
   * Add a log handler.
   *
   * @param {Object} options Options.
   * @param {String} options.id Handler ID.
   * @param {String} options.stream Output stream: `Serial`, `Serial1`, `USBSerial1`, etc.
   * @param {String} [options.format] Message format: `default`, `json`.
   * @param {String} [options.level] Default logging level: `trace`, `info`, `warn`, `error`, `none`, `all`.
   * @param {Array} [options.filters] Category filters.
   * @param {Number} [options.baudRate] Baud rate.
   * @return {Promise}
   */


  async addLogHandler({
    id,
    stream,
    format,
    level,
    filters,
    baudRate
  }) {
    const req = {
      id,
      level: LogLevel.toProtobuf(level || 'all')
    };

    switch ((format || 'default').toLowerCase()) {
      case 'default':
        {
          req.handlerType = _protocol.default.logging.LogHandlerType.DEFAULT_STREAM_HANDLER;
          break;
        }

      case 'json':
        {
          req.handlerType = _protocol.default.logging.LogHandlerType.JSON_STREAM_HANDLER;
          break;
        }

      default:
        {
          throw new RangeError(`Unknown message format: ${format}`);
        }
    }

    if (!stream) {
      throw new RangeError('Output stream is not specified');
    }

    switch (stream.toLowerCase()) {
      case 'serial':
        {
          req.streamType = _protocol.default.logging.StreamType.USB_SERIAL_STREAM;
          req.serial = {
            index: 0
          };
          break;
        }

      case 'usbserial1':
        {
          req.streamType = _protocol.default.logging.StreamType.USB_SERIAL_STREAM;
          req.serial = {
            index: 1
          };
          break;
        }

      case 'serial1':
        {
          req.streamType = _protocol.default.logging.StreamType.HW_SERIAL_STREAM;
          req.serial = {
            index: 1,
            baudRate
          };
          break;
        }

      default:
        {
          throw new RangeError(`Unknown output stream: ${stream}`);
        }
    }

    if (filters) {
      req.filters = filters.map(f => ({
        category: f.category,
        level: LogLevel.toProtobuf(f.level)
      }));
    }

    return this.sendRequest(_request.Request.ADD_LOG_HANDLER, req);
  }
  /**
   * Remove a log handler.
   *
   * @param {Object} options Options.
   * @param {String} options.id Handler ID.
   * @return {Promise}
   */


  async removeLogHandler({
    id
  }) {
    return this.sendRequest(_request.Request.REMOVE_LOG_HANDLER, {
      id
    });
  }
  /**
   * Get the list of active log handlers.
   *
   * @return {Promise<Object>}
   */


  async getLogHandlers() {
    const rep = await this.sendRequest(_request.Request.GET_LOG_HANDLERS);
    return rep.handlers.map(h => ({
      id: h.id
    }));
  } // Sends a Protobuf-encoded request


  sendRequest(req, msg, opts) {
    let buf = null;

    if (msg && req.request) {
      const m = req.request.create(msg); // Protobuf message object

      buf = req.request.encode(m).finish();
    }

    return this.sendControlRequest(req.id, buf, opts).then(rep => {
      let r = undefined;

      if (opts && opts.dontThrow) {
        r = {
          result: rep.result
        };
      } else if (rep.result !== _result.Result.OK) {
        throw new _error.RequestError(rep.result, (0, _result.messageForResultCode)(rep.result));
      }

      if (req.reply) {
        if (rep.data) {
          // Parse the response message
          r = (0, _assign.default)(req.reply.decode(rep.data), r);
        } else {
          // Create a message with default-initialized properties
          r = (0, _assign.default)(req.reply.create(), r);
        }
      }

      return r;
    });
  } // This method is used to send multiple requests to the device. The overall execution time can be
  // limited via the `ms` argument (optional)


  async timeout(ms, fn) {
    if (typeof ms === 'function') {
      fn = ms;
      ms = undefined;
    }

    if (!ms) {
      ms = _config.globalOptions.requestTimeout; // Default timeout
    }

    const s = new RequestSender(this, ms);
    return fn(s);
  }

  _readSectionData(section, offset, size) {
    const data = Buffer.alloc(size);
    let chunkSize = 4096;
    let chunkOffs = 0;

    const readChunk = () => {
      if (chunkOffs + chunkSize > size) {
        chunkSize = size - chunkOffs;
      }

      if (chunkSize === 0) {
        return _promise.default.resolve(data);
      }

      return this.sendRequest(_request.Request.READ_SECTION_DATA, {
        storage: section.storageIndex,
        section: section.sectionIndex,
        offset: offset + chunkOffs,
        size: chunkSize
      }).then(rep => {
        rep.data.copy(data, chunkOffs);
        chunkOffs += chunkSize;
        return readChunk();
      });
    };

    return readChunk();
  }

  _writeSectionData(section, offset, data) {
    return _promise.default.resolve().then(() => {
      if (section.needClear) {
        return this._clearSectionData(section);
      }
    }).then(() => {
      let chunkSize = 4096;
      let chunkOffs = 0;

      const writeChunk = () => {
        if (chunkOffs + chunkSize > data.length) {
          chunkSize = data.length - chunkOffs;
        }

        if (chunkSize === 0) {
          return _promise.default.resolve();
        }

        return this.sendRequest(_request.Request.WRITE_SECTION_DATA, {
          storage: section.storageIndex,
          section: section.sectionIndex,
          offset: offset + chunkOffs,
          data: data.slice(chunkOffs, chunkOffs + chunkSize)
        }).then(() => {
          chunkOffs += chunkSize;
          return writeChunk();
        });
      };

      return writeChunk();
    });
  }

  _clearSectionData(section) {
    return this.sendRequest(_request.Request.CLEAR_SECTION_DATA, {
      storage: section.storageIndex,
      section: section.sectionIndex
    });
  }

  _getSectionDataSize(section) {
    return this.sendRequest(_request.Request.GET_SECTION_DATA_SIZE, {
      storage: section.storageIndex,
      section: section.sectionIndex
    }).then(rep => rep.size);
  }

  _getStorageInfo() {
    // Check if there's a cached storage info
    if (this._storageInfo) {
      return _promise.default.resolve(this._storageInfo);
    } // Request storage info from the device


    return this.sendRequest(_request.Request.DESCRIBE_STORAGE).then(rep => {
      const storage = {
        modules: [],
        factory: null,
        config: null,
        eeprom: null,
        hasModularFirmware: true
      };

      for (let storageIndex = 0; storageIndex < rep.storage.length; ++storageIndex) {
        const pbStorage = rep.storage[storageIndex];

        for (let sectionIndex = 0; sectionIndex < pbStorage.sections.length; ++sectionIndex) {
          const pbSection = pbStorage.sections[sectionIndex];
          const section = {
            storageIndex: storageIndex,
            sectionIndex: sectionIndex,
            size: pbSection.size,
            needClear: !!(pbSection.flags & _protocol.default.SectionFlag.NEED_CLEAR)
          };

          switch (pbSection.type) {
            // Firmware module
            case _protocol.default.SectionType.FIRMWARE:
              {
                const pbFirmwareModule = pbSection.firmwareModule;

                if (pbFirmwareModule.type === _protocol.default.FirmwareModuleType.MONO_FIRMWARE) {
                  storage.hasModularFirmware = false;
                }

                section.moduleType = FirmwareModule.fromProtobuf(pbFirmwareModule.type);

                if (pbFirmwareModule.index) {
                  section.moduleIndex = pbFirmwareModule.index;
                }

                storage.modules.push(section);
                break;
              }
            // Factory firmware

            case _protocol.default.SectionType.FACTORY_BACKUP:
              {
                storage.factory = section;
                break;
              }
            // Device configuration

            case _protocol.default.SectionType.CONFIG:
              {
                storage.config = section;
                break;
              }
            // EEPROM

            case _protocol.default.SectionType.EEPROM:
              {
                storage.eeprom = section;
                break;
              }
          }
        }
      }

      this._storageInfo = storage;
      this.once('closed', () => {
        this._storageInfo = null;
      });
      return this._storageInfo;
    });
  }

}

exports.Device = Device;
//# sourceMappingURL=device.js.map